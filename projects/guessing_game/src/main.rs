use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Угадайте число");
// Функция rand::thread_rng даст нам конкретный генератор
// случайных чисел, который мы намерены ис­пользовать — он
// является локальным для текущего потока и инициализируется
// операционной системой. Затем мы вызываем метод gen_range
// на указанном гене­раторе случайных чисел. Этот метод
// определен типажом Rng , который мы ввели в область видимости
// с помощью инструкции use rand::Rng . Метод gen_range бе­рет
// два числа в качестве аргументов и генерирует случайное число
// между ними. Результат включает в себя нижнюю границу, но
// исключает верхнюю, поэтому для того, чтобы запросить число
// между 1 и 100, нам нужно указать 1 и 101.
    let secret_number = rand::thread_rng().gen_range(1, 101);

    // программа по-прежнему выводит секретное число.
    // Это пригодилось для тестирования, но портит игру.
    // Давайте удалим макрокоман­ду println!,
    // которая выводит секретное число:
    //println!("Секретное число равно {}", secret_number);

    loop {
        println!("Пожалуйста, введите свою догадку.");
//ключевое слово mut перед именем переменной, чтобы сделать переменную изменяемой
//Синтаксис :: в строке кода ::new указывает на то, что new является функцией, свя­занной с типом String
        let mut guess = String::new();
// .read_line(&mut guess) вызывает метод read_line,
// задан­ный для дескриптора стандартного ввода данных
// для получения данных от поль­зователя
// Символ & указывает на то, что этот аргумент является ссылкой, которая дает
// возможность многочисленным частям кода обращаться к  одному фрагменту
// данных без многократного копирования этих данных в память
        io::stdin().read_line(&mut guess)
            .expect("Не получилось прочитать строку");
// В итоге мы хотим конвертировать значение типа String,
// которое программа читает на входе, в числовой тип,
// чтобы численно сравнить его с секретным чис­лом.
// Мы можем это сделать, добавив следующие две строки кода
// в тело функции main:
        // let guess: u32 = guess.trim().parse()
        //     .expect("Пожалуйста, наберите число!");
// Метод trim для типа String устраняет любые пробелы в начале и конце.
// Несмотря на то что тип u32 может содержать только числовые символы,
// пользователь должен на­жать клавишу ENTER и тем самым выполнить метод
// read_line. Когда пользова­тель нажимает ENTER, символ новой строки
// добавляется в конец строкового зна­чения. Например, если пользователь
// набирает 5 и нажимает ENTER, то переменная guess выглядит следующим
// образом: 5\n. \n обозначает «новую строку», то есть результат нажатия
// клавиши ENTER. Метод trim исключает \n, давая в результате только 5.
// Метод parse, определенный для типа String, делает разбор строкового значения
// и преобразует его в какое-то число. Поскольку этот метод извлекает различные
// типы чисел, нужно указать точный тип числа, который мы хотим, используя let
// guess: u32. Двоеточие (:) после guess говорит о том, что мы аннотируем тип
// пере­менной. В Rust имеется несколько встроенных числовых типов: u32, который мы
// рассматриваем, является беззнаковым 32-битным целочисленным типом. Это хо­роший
// выбор по умолчанию для малого положительного числа. Кроме того, аннотация u32
// в этом примере программы и сравнение с переменной secret_number означают,
// что Rust логически выведет, что переменная secret_number тоже должна иметь
// тип u32. И, таким образом, те­перь будут сравниваться два значения одного и того же типа

    // Игнорирование нечислового загаданного числа и запрос следующего
    // загаданного числа вместо аварийного завершения программы
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        // Подчеркивание _ является всеохватываю­щим значением.
        // В данном примере мы хотим, чтобы совпали все значения Err,
        // не­зависимо от того, какая информация у них внутри. Поэтому
        // программа выполнит код второго рукава continue, который
        // говорит программе перейти к следующей итерации цикла и
        // запросить еще одно загаданное число. Таким образом, по сути,
        // программа игнорирует все ошибки, с которыми может столкнуться 
        // метод parse

        println!("Вы загадали: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Слишком малое число!"),
            Ordering::Greater => println!("Слишком большое число!"),
            Ordering::Equal => {
                println!("Вы выиграли!");
                break;
            }
        }
    }
}
